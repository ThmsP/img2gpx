# -*- coding: utf-8 -*-
"""terrains.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OnIlVr7_iI2cLBQp10XpMCKpOhJtJOcc
"""



"""# Find terrains under a GPX

For a GPX of 15 000 points, it will take 15 minutes.

Segmentez les grandes traces en sections de moins de 10 000 points (mais gardez-les dans un seul GPX).

## Init
"""

#from typing_extensions import TypeVarTuple
from shapely.geometry import LineString, Point, box, MultiPoint, Polygon, mapping
from shapely.ops import unary_union, orient
import matplotlib.pyplot as plt
from geopy.distance import geodesic
import ipywidgets as widgets
from IPython.display import display, HTML, Javascript, FileLink
from google.colab import files
import requests
import xml.etree.ElementTree as ET
import math
import requests
import time
from datetime import datetime
import urllib.parse
import json

STATS = {
    'MainStreet': [0,'Main streets'],
    'Street': [0,'Streets'],
    'MainRoad': [0,'Main roads'],
    'SecondaryRoad': [0,'Secondary roads'],
    'SmallRoad': [0,'Small roads'],
    'Unclassified': [0,'Unclassified roads'],
    'AsphaltedCycleway': [0,'Asphalted Cycleways'],
    'CompactedCycleway': [0,'Compacted Cycleways'],
    'Track1': [0,'Track grade 1'],
    'Track2': [0,'Track grade 2'],
    'Track3': [0,'Track grade 3'],
    'Track4': [0,'Track grade 4'],
    'Track5': [0,'Track grade 5'],
    'Track0': [0,'Track grade unknown'],
    'Path': [0,'Paths'],
    'Unknown': [0,'Unknown']
}

start_time = None
route_name = 'OSM'
overpass_query = ""
overpass_result = None
gpx_tree = None
export_geojson = ""

"""## Process functions"""

def handle_upload(change):
    global start_time,route_name,gpx_tree

    try:
      start_time = time.time()

      uploaded_file = change['owner']
      gpx_file_content = uploaded_file.value
      gpx_file_name = uploaded_file.metadata[0]['name']
      print(f"GPX file {gpx_file_name} loaded")

      gpx_file_data = next(iter(gpx_file_content.values()))
      gpx_file_bytes = gpx_file_data['content']
      gpx_file_bytes_decoded = gpx_file_bytes.decode('utf-8')
      gpx_tree = ET.ElementTree(ET.fromstring(gpx_file_bytes_decoded))

      route_name = None
      metadata_name = gpx_tree.find('.//{http://www.topografix.com/GPX/1/1}metadata/{http://www.topografix.com/GPX/1/1}name')
      if metadata_name is not None:
          route_name = metadata_name.text
      else:
          trk_name = gpx_tree.find('.//{http://www.topografix.com/GPX/1/1}trk/{http://www.topografix.com/GPX/1/1}name')
          if trk_name is not None:
              route_name = trk_name.text

      print_duration("Upload and building tree done ")

      # Itérer sur chaque segment de parcours (trkseg)
      trksegs = gpx_tree.findall('.//{http://www.topografix.com/GPX/1/1}trkseg')
      return process(trksegs)

    except Exception as e:
        print(f"Error: {e}")
        return False


def process(trksegs):

    print("Segments:", len(trksegs))
    i = 0
    for trkseg in trksegs:
      if overpass(trkseg):
        print("Segment:",i)
        print_duration("Overpass done")
        analyse(trkseg)
        i += 1

    if i>0:
      print_stats()
      print_duration("Duration:")
      return True
    else:
      print("Overpass problem")
      return False

def print_duration(message):
    global start_time
    duration = time.time() - start_time
    print(message, f" {duration:.2f} seconds")

"""## Graphics"""

def print_stats():
    global STATS,route_name

    km_total = sum(v[0] for v in STATS.values())
    if km_total==0: return False
    print('km: ',meters2km(km_total))
    #print(STATS)

    categories =[]
    for cat in STATS.values():
      categories.append(cat[1])

    values =[]
    for value in STATS.values():
      values.append(meters2km(value[0]))

    colors = []
    for terrain in STATS.keys():
      colors.append(terrainColor(terrain))

    # 3 lignes, 1 colonne
    fig, axs = plt.subplots(3, 1, figsize=(7, 15))

    # Horizontal bar graph
    bars = axs[0].barh(categories, values, color=colors, height=0.9)
    axs[0].invert_yaxis()
    axs[0].set_xlim(0, max(values) * 1.2)
    axs[0].set_title(route_name+" statistics (OSM data)")
    axs[0].tick_params(axis='y', which='major', pad=5)

    # Ajout des étiquettes de valeur
    for index, value in enumerate(values):
        if value != 0:
            axs[0].text(value, index, f" {value:.1f}km", va='center')

    # Surfaces
    street = STATS['Street'][0]+STATS['MainStreet'][0]
    nationalRoad = STATS['MainRoad'][0]
    road = STATS['SmallRoad'][0]+STATS['SecondaryRoad'][0]+STATS['Unclassified'][0]+nationalRoad
    cycleway = STATS['AsphaltedCycleway'][0]+STATS['CompactedCycleway'][0]
    track = STATS['Track1'][0]+STATS['Track2'][0]+STATS['Track3'][0]+STATS['Track4'][0]+STATS['Track5'][0]+STATS['Track0'][0]
    path = STATS['Path'][0]+STATS['Unknown'][0]

    asphalt = STATS['AsphaltedCycleway'][0] + street + road
    ground = track + path + STATS['CompactedCycleway'][0]

    # Pie chart 1
    pie_colors = [terrainColor('MainRoad'), terrainColor('Path')]
    sizes = [asphalt, ground]
    labels = [f'{asphalt/(asphalt + ground) * 100:.0f}%\nAsphalt',
          f'{ground/(asphalt + ground) * 100:.0f}%\nGround']

    axs[1].pie(sizes, labels=labels, colors=pie_colors, labeldistance=0.5,textprops={'color': 'white','fontweight': 'bold','ha': 'center', 'va': 'center'})
    axs[1].axis('equal')
    axs[1].set_title(route_name+" surfaces (OSM data)", y=1.01)

    # Data for pie chart 2
    pie_colors = [terrainColor('Road'), terrainColor('Street'), terrainColor('Cycleway'), terrainColor('Track'), terrainColor('Path')]
    sizes = [road, street, cycleway, track, path]
    labels = ['Roads', 'Streets', 'Cycleways', 'Tracks', 'Paths']
    wedges, texts, autotexts = axs[2].pie(sizes, colors=pie_colors, autopct=custom_autopct)
    axs[2].axis('equal')
    axs[2].set_title(route_name+" terrains (OSM data)", y=1.01)

    total = sum(sizes)
    percentages = [(size / total) * 100 for size in sizes]
    rounded_percentages = [round(percentage) for percentage in percentages]
    non_zero_indices = [i for i, percentage in enumerate(rounded_percentages) if percentage > 0]
    filtered_labels = [labels[i] for i in non_zero_indices]
    filtered_colors = [pie_colors[i] for i in non_zero_indices]
    filtered_wedges = [wedges[i] for i in non_zero_indices]

    axs[2].legend(filtered_wedges, filtered_labels, title="", loc='upper center', bbox_to_anchor=(0.5, 0.05), ncol=len(filtered_labels), frameon=False, labelspacing=0.05)

    plt.tight_layout()
    plt.subplots_adjust(hspace=0.2,bottom=0.2)
    plt.show()

    #Komoot compare
    display(HTML("<h3>Komoot like</h3>"))
    print(f"Sentier: {meters2km(path-STATS['Unknown'][0])} km")
    print(f"Chemin: {meters2km(track)} km")
    print(f"Piste cyclable: {meters2km(cycleway)} km")
    print(f"Rue: {meters2km(street)} km")
    print(f"Route: {meters2km(road-nationalRoad)} km")
    print(f"Nationale: {meters2km(nationalRoad)} km")
    print(f"Hors réseau (inconnu): {meters2km(STATS['Unknown'][0])} km")

    print(f"Ashalt: {meters2km(asphalt)} km")
    print(f"Ground: {meters2km(ground)} km")

def custom_autopct(pct):
    return ('%1.0f%%' % pct) if round(pct) > 2 else ''

def terrainColor(terrain):
    global palette
    if terrain=='MainStreet' or terrain=='Street':
        return '#85C1E9' #Pale sky blue
    if terrain=='Road' or terrain=='MainRoad' or terrain=='SecondaryRoad' or terrain=='SmallRoad':
        return '#5DADE2' #Light sky blue
    if terrain=='Cycleway' or terrain=='AsphaltedCycleway' or terrain=='CompactedCycleway':
        return '#AEF359' #Green lemon
    if terrain=='Track1':
        return '#009150' #Spanish Green
    if terrain=='Track' or terrain=='Track2' or terrain=='Track3' or terrain=='Track4' or terrain=='Track5' or terrain=='Track0':
        return '#FFD700' #Golden sun
    if terrain=='Path':
        return '#FF4500' #Sun red-orange
    if terrain=='Unclassified':
        return '#A569BD' #Purple twilight
    if terrain=='Unknown':
        return '#000000' #Black
    return "#000000"
    #E86100 Spanish Orange (trop proche rouge)

def meters2km(meter):
  return round(meter/1000,1)

"""## Technical functions"""

def polygon_box(trkseg, namespace="{http://www.topografix.com/GPX/1/1}"):

    gpx_points = []
    print("Polygon box started")

    # Compter le nombre de points dans le segment actuel
    trkpt_count = len(list(trkseg.iter(f'{namespace}trkpt')))
    print("Points:", trkpt_count)

    i=0
    for trkpt in trkseg.iter(f'{namespace}trkpt'):
        lat = float(trkpt.get('lat'))
        lon = float(trkpt.get('lon'))
        gpx_points.append((lon, lat))

        i+=1
        update_progress(i,trkpt_count,10)

    if len(gpx_points) > 2:
        reverse_points = list(reversed(gpx_points[1:-1]))
        all_points = gpx_points + reverse_points
        convex_hull = Polygon(all_points)
        convex_hull = convex_hull.buffer(0.00001)

        poly_coords = ' '.join(f'{y} {x}' for x, y in convex_hull.exterior.coords[:-1])
        return poly_coords

    else:
        print("Pas assez de points pour former un polygone.")
        return None


def overpass(trkseg):
  global overpass_query,overpass_result

  print_duration("Overpass query started")
  poly_coords = polygon_box(trkseg)
  print_duration("Poly_coords done")

  overpass_query = f"""[out:json];(way[highway](poly:'{poly_coords}'););out geom;"""

  #Debug
  print(f'https://overpass-turbo.eu/')
  download_button1 = widgets.Button(description="Overpass Query")
  download_button1.on_click(on_button_save_overpass)
  display(download_button1)

  overpass_url = 'https://overpass-api.de/api/interpreter'
  response = requests.post(overpass_url, data={'data': overpass_query})
  print_duration("Overpass response")
  if response.status_code != 200:
    raise Exception(f'Error fetching data from Overpass API: {response.status_code}')
    return False
  overpass_result = response.json()
  with open("overpass.json", "w") as file:
      file.write(json.dumps(overpass_result, indent=4))
  return True


def analyse(trkseg):
  global STATS,export_geojson,overpass_result

  ways_data = overpass_result['elements']
  way_lines = []

  # Remplir la liste way_lines avec toutes les lignes des chemins
  print_duration("Way lines building started")
  i = 0
  way_count = len(ways_data)
  for way in ways_data:
      way_segments = extract_segments(way['geometry'])
      for way_segment in way_segments:
          way_line = LineString(way_segment)
          way_bbox = enlarge_bbox(way_line.bounds)
          way_lines.append((way_line, way_bbox, way))

      i+=1
      update_progress(i,way_count,20,10)

  known_seg = [] # For debug
  print_duration("Searching overlaps starded")
  gpx_segments = create_segments(trkseg)
  i = 0
  seg_count = len(gpx_segments)
  for gpx_segment in gpx_segments:

    dist = distance(gpx_segment)

    nearest = nearest_way(gpx_segment, way_lines)
    terrain = find_terrain(nearest)
    if terrain == 'Unknown':
        if nearest:
          print(nearest)
    color=terrainColor(terrain)
    known_seg.append((gpx_segment,color))
    STATS[terrain][0]+=dist

    i+=1
    update_progress(i,seg_count,70,30)

  #Debug
  geo_obj=geojson_object(known_seg)
  geojson_url(geo_obj)
  export_geojson = geojson_str(geo_obj)
  download_button2 = widgets.Button(description="Geojson Query")
  download_button2.on_click(on_button_save_geojson)
  display(download_button2)

  return True


def nearest_way(gpx_segment, way_lines, distance_threshold=1):
    closest = find_closest_way(gpx_segment, way_lines)
    if closest[0] is None:
        return False  # Aucun segment de chemin n'a été trouvé

    gpx_line = closest[2]
    segment_distance = gpx_line.distance(closest[0])

    if segment_distance < distance_threshold:
      return closest[1]
    return False

def find_closest_way(gpx_segment, way_lines):
    min_distance_sum = float('inf')
    closest_line = None
    closest_way = None
    gpx_start, gpx_end = map(Point, gpx_segment)
    gpx_line = LineString(gpx_segment)
    gpx_bbox = gpx_line.bounds

    #print_on = False
    #test_segment = [(43.506887,3.609634),(43.506972,3.609569)]  #[(43.488074, 3.669648), (43.488385, 3.669391)]
    #if test_segment == gpx_segment:
    #    print("*** Test ***")
    #    print_on = True

    for way_line, way_bbox, way in way_lines:

        if not (gpx_bbox[2] < way_bbox[0] or
          gpx_bbox[0] > way_bbox[2] or
          gpx_bbox[3] < way_bbox[1] or
          gpx_bbox[1] > way_bbox[3]):

            #distance_en_metres=distance_en_degres×111,000
            #111m=0.001
            start = gpx_start.distance(way_line)
            if start<0.0001: #10m
              distance_sum = start + gpx_end.distance(way_line)
              #if print_on: print("start:",start,distance_sum,way['tags'])
              if distance_sum < min_distance_sum:
                  min_distance_sum = distance_sum
                  closest_line = way_line
                  closest_way = way['tags']

    return closest_line,closest_way,gpx_line

def enlarge_bbox(bbox, margin=0.002):
    minx, miny, maxx, maxy = bbox
    return (minx - margin, miny - margin, maxx + margin, maxy + margin)

def create_segments(trkseg):
    print_duration("Create segments")
    segments = []
    trkpts = trkseg.findall('{http://www.topografix.com/GPX/1/1}trkpt')
    for i in range(len(trkpts) - 1):
        segment = [(float(trkpts[i].attrib['lat']), float(trkpts[i].attrib['lon'])),
                    (float(trkpts[i + 1].attrib['lat']), float(trkpts[i + 1].attrib['lon']))]
        segments.append(segment)
    return segments

def extract_segments(geometry):
    segments = []
    for i in range(len(geometry) - 1):
        point1 = (geometry[i]['lat'], geometry[i]['lon'])
        point2 = (geometry[i + 1]['lat'], geometry[i + 1]['lon'])
        segment = [point1, point2]
        segments.append(segment)
    return segments

def distance(gpx_segment):
  length = 0
  for i in range(len(gpx_segment) - 1):
      point1 = gpx_segment[i]
      point2 = gpx_segment[i + 1]
      length += geodesic(point1, point2).meters
  return length

def create_progress_bar():
    display(HTML("""
        <div style="width: 100%; background-color: #f0f0f0">
            <div id="progress-bar" style="width: 0%; background-color: #b0e57c; text-align: center">
                0%
            </div>
        </div>
        <script>
        function update_progress(progress) {
            var bar = document.getElementById('progress-bar');
            bar.style.width = progress + '%';
            bar.innerText = progress + '%';
        }
        </script>
    """))

def update_progress(progress,progress_max,progress_fact,progress_min=0):
    progress=round(progress_min+(progress/progress_max)*progress_fact)
    display(Javascript(f"update_progress({progress})"))

def on_button_save_overpass(event):
    global overpass_query
    print(len(overpass_query))
    #export_filename = "overpass_"+datetime.now().strftime('%H:%M:%S')+".txt"
    export_filename = "overpass.txt"
    on_button_save(overpass_query,export_filename)

def on_button_save_geojson(event):
    global export_geojson
    print(len(export_geojson))
    #export_filename = "geojson_"+datetime.now().strftime('%H:%M:%S')+".json"
    export_filename = "geojson.json"
    on_button_save(export_geojson,export_filename)

def on_button_save(export_str,export_filename):
    try:
        if export_str=="" or export_filename=="":
            print("Nothing to save")
            return False
        with open(export_filename, "w") as file:
            file.write(export_str)
        files.download(export_filename)
    except Exception as e:
        print(f'Error: {e}')

"""## OSM analysis

Choices have to be made, there.
"""

def find_terrain(nearest):

  if not nearest: #No way find around on the map
    return 'Unknown'

  surface = nearest.get('surface', '').lower()
  cycleway = nearest.get('cycleway', '').lower()
  bicycle = nearest.get('bicycle', '').lower()
  highway = nearest.get('highway', '').lower()

  if cycleway == 'yes' or cycleway == 'sidewalk' or bicycle == 'designated' or bicycle == 'yes' or highway == 'cycleway':
    if surface == 'compacted':
        return 'CompactedCycleway'
    return 'AsphaltedCycleway'

  if highway == 'unclassified':
    name = nearest.get('name', '').lower()
    if 'route' in name:
        return 'SmallRoad'
    if 'rue' in name:
        return 'Street'
    if 'asphalt' in surface:
        return 'SmallRoad'
    source = nearest.get('source', '').lower()
    if 'bing' in source:
        return 'SmallRoad'
    if 'chemin' in name:
        return 'Track1'
    return 'Unclassified'

  if highway == 'motorway' or highway == 'trunk' or highway == 'primary' :
    return 'MainRoad'

  if highway == 'secondary':
    return 'SecondaryRoad'

  if highway == 'tertiary':
    return 'SmallRoad'

  if highway == 'residential' or highway == 'living_street':
    name = nearest.get('name', '').lower()
    if 'boulevard' in name or 'avenue' in name:
        return 'MainStreet'
    return 'Street'

  if highway == 'track':
    tracktype = nearest.get('tracktype', '').lower()
    tracktype = tracktype.replace('grade','')
    if tracktype == "":
      return 'Track0'
    return 'Track'+tracktype

  if highway == 'path' or highway == 'footway' or highway == 'pedestrian' or highway == 'steps':
    return 'Path'

  if highway == 'proposed':
    proposed = nearest.get('proposed', '').lower()
    if proposed == 'path':
        return 'Path'
    if proposed == 'track':
        return 'Track1'
    return 'Unclassified'

  if highway == 'service':
    tracktype = ""
    if nearest.get('tracktype'):
        tracktype = nearest['tracktype'].lower()
        tracktype = tracktype.replace('grade','')
        return 'Track'+tracktype
    name = ""
    if nearest.get('name'):
        name = nearest['name'].lower()
        if 'rue' in name in name:
          return 'Street'

    return 'Track1'

  return 'Unknown'

"""## Debug with GEOjson

https://geojson.io/

https://arthur-e.github.io/Wicket/sandbox-gmaps3.html

"""

def geojson_object(segments):

  if len(segments)==0:
      return False

  combined_features = []
  for seg, color in segments:

    point1 = seg[0]
    lat1, lon1 = point1
    point2 = seg[1]
    lat2, lon2 = point2
    feature = {
        "type": "Feature",
        "geometry": {
          "type": "LineString",
          "coordinates": [
              [lon1, lat1],
              [lon2, lat2]
          ]
          },
          "properties": {
              "stroke": color,
              "stroke-width": 5,
              "stroke-opacity": 1,
              "segment": seg
          }
    }
    combined_features.append(feature)

  if len(combined_features)==0:
      return False

  geojson_object = {
      "type": "FeatureCollection",
      "features": combined_features
  }

  return geojson_object

def geojson_link(segments):
  return geojson_url(geojson_object(segments))

def geojson_url(geojson_object):
  if geojson_object==False:
    return False
  json_str = json.dumps(geojson_object)
  encoded_json_str = urllib.parse.quote(json_str)
  if len(encoded_json_str)<300000:
      #print("link")
      url = f"http://geojson.io/#data=data:application/json,{encoded_json_str}"
      print(url)
  else:
      print("Load the query into http://geojson.io")
  return True

def geojson_str(geojson_object):
  return json.dumps(geojson_object)

def polygons_link(convex_hull):

  convex_hull = orient(convex_hull, sign=1.0)
  geojson_object = {
      "type": "FeatureCollection",
      "features": [
          {
              "type": "Feature",
              "geometry": {
                  "type": "Polygon",
                  "coordinates": [mapping(convex_hull)]
              },
              "properties": {}
          }
      ]
  }
  json_str = json.dumps(geojson_object)
  encoded_json_str = urllib.parse.quote(json_str)
  url = f"http://geojson.io/#data=data:application/json,{encoded_json_str}"
  print(url)

"""## Display"""

# Create widgets
gpx_upload = widgets.FileUpload(
    accept='.gpx',
    multiple=False
)

# Set up event handlers
gpx_upload.observe(handle_upload, names='value')
display(HTML("<h3>Upload a GPX file:</h3>"))
display(gpx_upload)
create_progress_bar()

"""### OSM track grades
- **Grade 1 (Solid):** Paved or similarly solid tracks, which are easy to drive on. But we can find old asphalt and gravel road. Many errors on this grade.
  
- **Grade 2 (Hard):** Unpaved but solid tracks, possibly with some gravel.
  
- **Grade 3 (Intermediate):** Tracks are mostly solid but might have some more uneven spots, making them more challenging to traverse.
  
- **Grade 4 (Soft):** Tracks are soft and may be challenging for vehicles without off-road capabilities.
  
- **Grade 5 (Very Soft):** Tracks are very soft, often challenging or impossible to traverse without a specialized off-road vehicle.

### Surfaces
* **OSM unclassified:** most of the time small roads
* **Unknown:** not on the the map, mostly single tracks
* **Streets:** Streets  + Main streets
* **Roads:** Small roads + Secondary roads + Main roads + OSM unclassified
* **Cycleways:** Asphalt Cycleways + Compacted Cycleways
* **Asphalt:** Asphalt Cycleways + Streets + Roads
* **Tracks:** Track grade 1 + Track grade 2 + Track grade 3 + Track grade 4 + Track grade 5 + Track grade unknown
* **Paths:** Paths + Unknown

##Test zone
"""

def on_button_test():
  #analyse()
  #print_stats()
  pass

test_button = widgets.Button(description="Test")
test_button.on_click(on_button_test)
display(test_button)